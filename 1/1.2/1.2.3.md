# オーダー
前節では同じ手続でも,使われる計算リソースが大きく異なることがあるということを学んだ.
この違いを表現するために**増加のオーダー(order of growrh)**の記法を利用することができる.

※SICPには載っていないが,この記法は一般的に「O記法」に近いものである.(同じ？)
O記法はよくアルゴリズムの計算量の解析の際に使われていたりする.

## 記法について
この記法は「ある処理の**何かの量**の増加の仕方が大体どのようになっているかを表す記法」である.

**何か**の部分には「ステップ数(計算量)」や「使用するメモリ(記憶域)」であったりし,
柔軟に使うことができる.

例)
- ステップ数を 2n 必要とする増加のオーダーはΘ(n).
    - 係数は無視されてΘ(n)と表す.
- 記憶域を 4log(n) 必要とする増加のオーダーはΘ(log(n)).
- ステップ数を 3n^2 + 3 必要とする増加のオーダーはΘ(n^2).
    - 足される数も無視.

また以下のようにも表現できる.
- Θ(n)ステップ必要とする演算にはステップ数が4n
や3n+1 であるものが挙げられる.

---
ここから今までやった1.2.1と1.2.2を例に,
各オーダーを調べててみる.

### 階乗の例

#### ステップ数(計算量)について

階乗を求める線形再帰の手続では,ステップ数は入力n に対して比例するため,
必要なステップ数はΘ(n)に従い増加する.

例) (factorial 6)について考える.

(fanctorial 6)は

    (* 6 (* 5 (* 4 ( * 3 (* 2 1))))

と表せるため, n=6 とした時(fanctorial)が呼び出された回数は6回となっている.

入力6に対して, 必要なステップ数は入力の同じ6である.

このとき,
「入力nに対して, 必要なステップ数は**Θ(n)**にしたがって増加する」
と表現することができる.

また,反復式階乗の際も計算量のステップ数はO(n)となる.

#### 記憶域について
線形再帰の際の増加のオーダーはΘ(n)であったが,

線形反復の際の増加のオーダーはΘ(1)
(= 定数でありnがどんな数字でも変化がない)
となっている.

---

### フィボナッチ数を求める計算

木再帰フィボナッチ演算は
Θ(ψ^n)ステップと記憶域Θ(n)を必要とします.

※ψ = (1 + √5) / 2 ≈ 1.6180

※正確にはΘ(ψ^(n-1)) [1]

例) (fib 4)を例にとって考える.

(fib 4) とすると,

    (+ (fib 3) (fib 2))
    = (+ (+ (fib 2) (fib 1)) (+ (fib 1) (fib 0)) )
    = (+  (+ (+ (fib 1) (fib 0)) (fib 1))  (+ (fib 1) (fib 0)) )

(fib 4)は(fib)を5回呼び出しています.

※(ψ^(4-1) = 4.235801032)

このように考えていくと,
- (fib 5) は8回呼び出している.(ψ^(5-1) =6.85352606978)
- (fib 6) は13回呼び出している.(ψ^(6-1) =11.0890051809)
- (fib 7) は21回呼び出している.(ψ^(7-1) =17.9420103827)
- ...

のようになり,指数関数的に(fib)を呼び出す回数が増えていることから,

(fib)が大体ψ^(n-1) 回くらい呼びだされていることがわかる.

このことから入力nに対して, 必要なステップ数はψ^(n-1)回となる.

よって増加のオーダーはO(ψ^(n-1)) = **Θ(ψ^n)** となる.

---

# 参考ページ
[1]「フィボナッチ数の計算と計算量」,
<http://www.aoni.waseda.jp/ichiji/2012/java-01/java-14-3.html>,
2014年12月15日アクセス
