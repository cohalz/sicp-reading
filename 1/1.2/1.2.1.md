# 1.2 線形再帰と反復
階乗を求める関数を考える。  

```math
n! = n * (n - 1) * (n - 2) *** 3 * 2 * 1.
```

階乗を計算する一つの方法として、任意の正の整数*n*において、*n!*は*n*と*(n-1)!*の積に等しい、
という観察結果を利用する。

```maath
n! = n * [(n - 1) * (n - 2) *** 3 * 2 * 1] = n * (n - 1)!.
```

よって(n - 1)!を演算子、nを掛けることでn!を求めることができる。もし1!が1に等しいという
規約を付加すれば

```Scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```

1.1.5の置換モデルを用いてこの手続きが6!の計算を実行する様子を図にした。  
![Figure1.3](./Figure1.3.png "Figure1.3")

もうひとつの視点から階乗の計算を見る。
n!は最初に1と2をかけ、その結果を3荷掛け、次に4にかけ、nに辿り着くまで繰り返す。  
形式的には、積の実行と、１からnまでカウントするカウンタとを一緒に保持する。カウンタと積は
同時にあるステップから次へとルールに従い変更されるということでこの演算を説明できる。

```math
product ← counter * product
counter ← counter + 1
```

ここでn!とはカウンタがnを越えた時点での積の値であると規定する。
すると、

```Scheme
(define (factorial n)
  (fant-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
```
				 
というように書き換えられる。  


前回同様、置換モデルを用いて6!の演算をFigure 1.4として示す。
![Figure1.4](./Figure1.4.png "Figure1.4")

示した２つの処理は一見同じように見えるが、両者は同じ数学の関数を同じ領域で計算し、それぞれがn!を求める
のにnに比例したステップ数を必要としている。実際に両者のプロセスが全く同じ一連の乗算を実行し、
全く同じ一連の部分的な積を得る。一方で２つのプロセスの**形**は全く異なっていることが見て取れる。

１つ目のプロセスについて考える。Figure 1.3を見ると置換モデルが展開のあと、収縮していることがみてとれる。
展開は*deferred operations*(遅延演算)の連鎖(乗算のつらなり)を構築するプロセスとして起こる。
この連鎖を*recursive process*(再帰プロセス)と呼ぶ。再帰プロセスの実行にはインタプリタがのちの実行のために
操作の家庭を記録する必要がある。n!の演算では遅延乗算の**連鎖**の長さ、またそれに伴う追跡の必要な情報の量
が、nに比例して線形的に増加する。このようなプロセスのことを*linear recursive process*(線形再帰プロセス)
と呼ぶ。

一方２つ目のプロセスは展開も縮小もしない。各ステップにおいて追跡が必要な物はどのnに対しても変数*product,
counter, max-count*の現在値である。これを*iterativ process*(反復プロセス)と呼ぶ。
反復プロセスは限られた数の*state variables*(状態変数)により状態が集約されることが可能なもので、
状態変数がプロセス枚にどのように更新されるかという固定ルールとプロセスが呈すする条件を指定する






